# -*- coding: utf-8 -*-
"""algoritmos_halloween-python

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GK6szlVp1O1p2105FSTbICKvEj2LPNhH
"""

import random

def jogar_adivinhacao():
    """
    Função principal do Jogo de Adivinhação com tema de Halloween.
    A bruxa guarda um número secreto em seu caldeirão.
    """

    # 1. Configuração do Jogo
    print("🧙‍♀️ Bem-vindo à Cabana da Bruxa! 🕯️")
    print("A Bruxa de Salem guardou um *Número Secreto* em seu caldeirão.")
    print("Você tem poucas chances para descobrir, ou *UM FEITIÇO* cairá sobre você!\n")

    # Gera um número secreto aleatório entre 1 e 50
    # conceito: Uso da biblioteca 'random' para geração de numeros pseudo-aleatorios
    numero_secreto = random.randint(1, 50)

    # Define o número de tentativas
    # conceito; Uso da bliblioteca 'random' para geração de numero pseudo-aleatorios
    tentativas_maximas = 5
    tentativas_restantes = tentativas_maximas
    acertou = False

    # 2. Loop Principal do Jogo
    # conceito: 'while' loop para controla o fluxo do jogo enquanto o jogador tiver chances e não acertar.
    while tentativas_restantes > 0 and not acertou:
        print(f" Tentativas restantes: {tentativas_restantes}")

        # leitura da entrada do usuario
        try:
            chute = int(input("👉 Qual o seu palpite entre 1 e 50? "))
        except ValueError:
          # tratamento de erro; se a entrada não for um numero inteiro
            print("⚠️ Entrada inválida! Digite apenas números inteiros.\n")
            continue  # Volta ao início do loop sem gastar tentativa

        #3 validaçao da entrada
        if chute < 1 or chute > 50:
            print("⚠️ O palpite deve estar entre 1 e 50. Tente novamente.\n")
            continue

        # 4. Verificação do Palpite (Estruturas Condicionais)
        tentativas_restantes -= 1

        if chute == numero_secreto:
            print(f"\n✨ PARABÉNS! Você quebrou o feitiço! O número era *{numero_secreto}*.")
            acertou = True
        elif chute > numero_secreto:
            print("💀 Muito alto! O caldeirão borbulha dizendo que o número é *MENOR*.\n")
        else:  # chute < numero_secreto
            print("☠️ Muito baixo! A fumaça do caldeirão indica que o número é *MAIOR*.\n")

    # 5. Fim do Jogo
    if not acertou:
        print("\n❌ Suas chances acabaram! O feitiço está completo!")
        print(f"🔮 O Número Secreto da Bruxa era *{numero_secreto}*.")

if __name__ == "__main__":
    jogar_adivinhacao()

import random

def jogar_adivinhacao():
    """
    Função principal do Jogo de Adivinhação com tema de Halloween.
    A bruxa guarda um número secreto em seu caldeirão.
    """

    # 1. Configuração do Jogo
    print(" Bem-vindo à Cabana da Bruxa! ")
    print("A Bruxa de Salem guardou um *Número Secreto* em seu caldeirão.")
    print("Você tem poucas chances para descobrir, ou *UM FEITIÇO* cairá sobre você!\n")

    # Gera um número secreto aleatório entre 1 e 50
    # conceito: Uso da biblioteca 'random' para geração de numeros pseudo-aleatorios
    numero_secreto = random.randint(1, 50)

    # Define o número de tentativas
    # conceito; Uso da bliblioteca 'random' para geração de numero pseudo-aleatorios
    tentativas_maximas = 5
    tentativas_restantes = tentativas_maximas
    acertou = False

    # 2. Loop Principal do Jogo
    # conceito: 'while' loop para controla o fluxo do jogo enquanto o jogador tiver chances e não acertar.
    while tentativas_restantes > 0 and not acertou:
        print(f" Tentativas restantes: {tentativas_restantes}")

        # leitura da entrada do usuario
        try:
            chute = int(input(" Qual o seu palpite entre 1 e 50? "))
        except ValueError:
          # tratamento de erro; se a entrada não for um numero inteiro
            print(" Entrada inválida! Digite apenas números inteiros.\n")
            continue  # Volta ao início do loop sem gastar tentativa

        #3 validaçao da entrada
        if chute < 1 or chute > 50:
            print(" O palpite deve estar entre 1 e 50. Tente novamente.\n")
            continue

        # 4. Verificação do Palpite (Estruturas Condicionais)
        tentativas_restantes -= 1

        if chute == numero_secreto:
            print(f"\n PARABÉNS! Você quebrou o feitiço! O número era *{numero_secreto}*.")
            acertou = True
        elif chute > numero_secreto:
            print(" Muito alto! O caldeirão borbulha dizendo que o número é *MENOR*.\n")
        else:  # chute < numero_secreto
            print(" Muito baixo! A fumaça do caldeirão indica que o número é *MAIOR*.\n")

    # 5. Fim do Jogo
    if not acertou:
        print("\n Suas chances acabaram! O feitiço está completo!")
        print(f" O Número Secreto da Bruxa era *{numero_secreto}*.")

if __name__ == "__main__":
    jogar_adivinhacao()

import random
import os  # Módulo usado para limpar a tela do console

def exibir_forca(erros):

    """Desenha a forca de acordo com o número de erros."""
    # A forca é um exempo de como o algoritmo pode representar estados.
    estagios = [
        # 0 erros
        """
           +---+
           |   |
               |
               |
               |
               |
        =========
        """,
        # 1 erro
        """
           +---+
           |   |
           O   |
               |
               |
               |
        =========
        """,
        # 2 erros
        """
           +---+
           |   |
           O   |
           |   |
               |
               |
        =========
        """,
        # 3 erros
        """
           +---+
           |   |
           O   |
          /|   |
               |
               |
        =========
        """,
        # 4 erros
        """
           +---+
           |   |
           O   |
          /|\\  |
               |
               |
        =========
        """,
        # 5 erros
        """
           +---+
           |   |
           O   |
          /|\\  |
          /    |
               |
        =========
        """,
        # 6 erros
        """
           +---+
           |   |
           O   |
          /|\\  |
          / \\  |
               |
        =========
        """,
        ]

    print(estagios[erros])


def jogar_forca():
    """Função principal do Jogo da Forca com tema Halloween."""

    #  Limpar tela para melhor visualização (funciona no Linux/macOS/Windows)
    os.system('cls' if os.name == 'nt' else 'clear')

    print(" Bem-vindos à Forca Assustadora! ")
    print("Adivinhe o nome de um ser ou objeto de Halloween antes que o *FANTASMA* se complete!\n")

    # 1. Configuração (Lista de Palavras e Sorteio)
    # Conceito: Uso de 'list' para armazenar dados e 'random.choice' para seleção.
    palavras_halloween = ["ABOBORA", "VAMPIRO", "BRUXA", "ZUMBI", "CALDEIRAO", "MORCEGO", "FANTASMA", "CEMITERIO"]
    palavra_secreta = random.choice(palavras_halloween)

    # 2. Variáveis de Controle
    # Conceito: Manipulação de listas para manter o estado do jogo.
    letras_certas = []
    letras_erradas = []
    max_erros = 6
    erros = 0

    # 3. Loop Principal
    while erros < max_erros:
        # exibe o status da forca
        exibir_forca(erros)

        # Constrói a palavra a ser exibida (com underscores para letras não descobertas)
        # Conceito: Loop de iteração e concatenação de strings.
        palavra_atual = ""
        for letra in palavra_secreta:
            if letra in letras_certas:
                palavra_atual += letra + " "
            else:
                palavra_atual += "_ "

        print(f"Palavra: {palavra_atual}")
        print(f"Erros: {erros}/{max_erros}")
        print(f"Letras erradas: {', '.join(letras_erradas)}\n")

        # Verifica se o jogador venceu
        # Conceito: Estrutura de repetição para verificar se todas as letras foram adivinhadas.
        if "_" not in palavra_atual:
            print(f" VITÓRIA! A palavra era: {palavra_secreta} ")
            return # Encerra a função

        # 4. Entrada do Usuário
        tentativa = input("Chute uma letra: ").strip().upper()

        # Validação de entrada
        if len(tentativa) != 1 or not tentativa.isalpha():
            print(" Por favor, chute apenas uma letra!\n")
            continue

        # 5. Processamento da Tentativa
        # Conceito: Estrutura Condicional aninhada para verificar o estado da letra.
        if tentativa in letras_certas or tentativa in letras_erradas:
            print(f"Você já tentou a letra '{tentativa}'. Tente outra.\n")
        elif tentativa in palavra_secreta:
            print(f" Boa! A letra '{tentativa}' está na palavra.")
            letras_certas.append(tentativa)
        else:
            print(f" A letra '{tentativa}' não está na palavra. O Fantasma avança!")
            letras_erradas.append(tentativa)
            erros += 1

        print("-" * 30 + "\n")

    # 6. Derrota
    exibir_forca(erros)
    print(f" FIM DE JOGO! O Fantasma te pegou!")

    print(f"A palavra era: {palavra_secreta}")
if __name__ == "__main__":
    jogar_forca()