# -*- coding: utf-8 -*-
"""algoritmos_halloween-python

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GK6szlVp1O1p2105FSTbICKvEj2LPNhH
"""

import random

def jogar_adivinhacao():
    """
    FunÃ§Ã£o principal do Jogo de AdivinhaÃ§Ã£o com tema de Halloween.
    A bruxa guarda um nÃºmero secreto em seu caldeirÃ£o.
    """

    # 1. ConfiguraÃ§Ã£o do Jogo
    print("ğŸ§™â€â™€ï¸ Bem-vindo Ã  Cabana da Bruxa! ğŸ•¯ï¸")
    print("A Bruxa de Salem guardou um *NÃºmero Secreto* em seu caldeirÃ£o.")
    print("VocÃª tem poucas chances para descobrir, ou *UM FEITIÃ‡O* cairÃ¡ sobre vocÃª!\n")

    # Gera um nÃºmero secreto aleatÃ³rio entre 1 e 50
    # conceito: Uso da biblioteca 'random' para geraÃ§Ã£o de numeros pseudo-aleatorios
    numero_secreto = random.randint(1, 50)

    # Define o nÃºmero de tentativas
    # conceito; Uso da bliblioteca 'random' para geraÃ§Ã£o de numero pseudo-aleatorios
    tentativas_maximas = 5
    tentativas_restantes = tentativas_maximas
    acertou = False

    # 2. Loop Principal do Jogo
    # conceito: 'while' loop para controla o fluxo do jogo enquanto o jogador tiver chances e nÃ£o acertar.
    while tentativas_restantes > 0 and not acertou:
        print(f" Tentativas restantes: {tentativas_restantes}")

        # leitura da entrada do usuario
        try:
            chute = int(input("ğŸ‘‰ Qual o seu palpite entre 1 e 50? "))
        except ValueError:
          # tratamento de erro; se a entrada nÃ£o for um numero inteiro
            print("âš ï¸ Entrada invÃ¡lida! Digite apenas nÃºmeros inteiros.\n")
            continue  # Volta ao inÃ­cio do loop sem gastar tentativa

        #3 validaÃ§ao da entrada
        if chute < 1 or chute > 50:
            print("âš ï¸ O palpite deve estar entre 1 e 50. Tente novamente.\n")
            continue

        # 4. VerificaÃ§Ã£o do Palpite (Estruturas Condicionais)
        tentativas_restantes -= 1

        if chute == numero_secreto:
            print(f"\nâœ¨ PARABÃ‰NS! VocÃª quebrou o feitiÃ§o! O nÃºmero era *{numero_secreto}*.")
            acertou = True
        elif chute > numero_secreto:
            print("ğŸ’€ Muito alto! O caldeirÃ£o borbulha dizendo que o nÃºmero Ã© *MENOR*.\n")
        else:  # chute < numero_secreto
            print("â˜ ï¸ Muito baixo! A fumaÃ§a do caldeirÃ£o indica que o nÃºmero Ã© *MAIOR*.\n")

    # 5. Fim do Jogo
    if not acertou:
        print("\nâŒ Suas chances acabaram! O feitiÃ§o estÃ¡ completo!")
        print(f"ğŸ”® O NÃºmero Secreto da Bruxa era *{numero_secreto}*.")

if __name__ == "__main__":
    jogar_adivinhacao()

import random

def jogar_adivinhacao():
    """
    FunÃ§Ã£o principal do Jogo de AdivinhaÃ§Ã£o com tema de Halloween.
    A bruxa guarda um nÃºmero secreto em seu caldeirÃ£o.
    """

    # 1. ConfiguraÃ§Ã£o do Jogo
    print(" Bem-vindo Ã  Cabana da Bruxa! ")
    print("A Bruxa de Salem guardou um *NÃºmero Secreto* em seu caldeirÃ£o.")
    print("VocÃª tem poucas chances para descobrir, ou *UM FEITIÃ‡O* cairÃ¡ sobre vocÃª!\n")

    # Gera um nÃºmero secreto aleatÃ³rio entre 1 e 50
    # conceito: Uso da biblioteca 'random' para geraÃ§Ã£o de numeros pseudo-aleatorios
    numero_secreto = random.randint(1, 50)

    # Define o nÃºmero de tentativas
    # conceito; Uso da bliblioteca 'random' para geraÃ§Ã£o de numero pseudo-aleatorios
    tentativas_maximas = 5
    tentativas_restantes = tentativas_maximas
    acertou = False

    # 2. Loop Principal do Jogo
    # conceito: 'while' loop para controla o fluxo do jogo enquanto o jogador tiver chances e nÃ£o acertar.
    while tentativas_restantes > 0 and not acertou:
        print(f" Tentativas restantes: {tentativas_restantes}")

        # leitura da entrada do usuario
        try:
            chute = int(input(" Qual o seu palpite entre 1 e 50? "))
        except ValueError:
          # tratamento de erro; se a entrada nÃ£o for um numero inteiro
            print(" Entrada invÃ¡lida! Digite apenas nÃºmeros inteiros.\n")
            continue  # Volta ao inÃ­cio do loop sem gastar tentativa

        #3 validaÃ§ao da entrada
        if chute < 1 or chute > 50:
            print(" O palpite deve estar entre 1 e 50. Tente novamente.\n")
            continue

        # 4. VerificaÃ§Ã£o do Palpite (Estruturas Condicionais)
        tentativas_restantes -= 1

        if chute == numero_secreto:
            print(f"\n PARABÃ‰NS! VocÃª quebrou o feitiÃ§o! O nÃºmero era *{numero_secreto}*.")
            acertou = True
        elif chute > numero_secreto:
            print(" Muito alto! O caldeirÃ£o borbulha dizendo que o nÃºmero Ã© *MENOR*.\n")
        else:  # chute < numero_secreto
            print(" Muito baixo! A fumaÃ§a do caldeirÃ£o indica que o nÃºmero Ã© *MAIOR*.\n")

    # 5. Fim do Jogo
    if not acertou:
        print("\n Suas chances acabaram! O feitiÃ§o estÃ¡ completo!")
        print(f" O NÃºmero Secreto da Bruxa era *{numero_secreto}*.")

if __name__ == "__main__":
    jogar_adivinhacao()

import random
import os  # MÃ³dulo usado para limpar a tela do console

def exibir_forca(erros):

    """Desenha a forca de acordo com o nÃºmero de erros."""
    # A forca Ã© um exempo de como o algoritmo pode representar estados.
    estagios = [
        # 0 erros
        """
           +---+
           |   |
               |
               |
               |
               |
        =========
        """,
        # 1 erro
        """
           +---+
           |   |
           O   |
               |
               |
               |
        =========
        """,
        # 2 erros
        """
           +---+
           |   |
           O   |
           |   |
               |
               |
        =========
        """,
        # 3 erros
        """
           +---+
           |   |
           O   |
          /|   |
               |
               |
        =========
        """,
        # 4 erros
        """
           +---+
           |   |
           O   |
          /|\\  |
               |
               |
        =========
        """,
        # 5 erros
        """
           +---+
           |   |
           O   |
          /|\\  |
          /    |
               |
        =========
        """,
        # 6 erros
        """
           +---+
           |   |
           O   |
          /|\\  |
          / \\  |
               |
        =========
        """,
        ]

    print(estagios[erros])


def jogar_forca():
    """FunÃ§Ã£o principal do Jogo da Forca com tema Halloween."""

    #  Limpar tela para melhor visualizaÃ§Ã£o (funciona no Linux/macOS/Windows)
    os.system('cls' if os.name == 'nt' else 'clear')

    print(" Bem-vindos Ã  Forca Assustadora! ")
    print("Adivinhe o nome de um ser ou objeto de Halloween antes que o *FANTASMA* se complete!\n")

    # 1. ConfiguraÃ§Ã£o (Lista de Palavras e Sorteio)
    # Conceito: Uso de 'list' para armazenar dados e 'random.choice' para seleÃ§Ã£o.
    palavras_halloween = ["ABOBORA", "VAMPIRO", "BRUXA", "ZUMBI", "CALDEIRAO", "MORCEGO", "FANTASMA", "CEMITERIO"]
    palavra_secreta = random.choice(palavras_halloween)

    # 2. VariÃ¡veis de Controle
    # Conceito: ManipulaÃ§Ã£o de listas para manter o estado do jogo.
    letras_certas = []
    letras_erradas = []
    max_erros = 6
    erros = 0

    # 3. Loop Principal
    while erros < max_erros:
        # exibe o status da forca
        exibir_forca(erros)

        # ConstrÃ³i a palavra a ser exibida (com underscores para letras nÃ£o descobertas)
        # Conceito: Loop de iteraÃ§Ã£o e concatenaÃ§Ã£o de strings.
        palavra_atual = ""
        for letra in palavra_secreta:
            if letra in letras_certas:
                palavra_atual += letra + " "
            else:
                palavra_atual += "_ "

        print(f"Palavra: {palavra_atual}")
        print(f"Erros: {erros}/{max_erros}")
        print(f"Letras erradas: {', '.join(letras_erradas)}\n")

        # Verifica se o jogador venceu
        # Conceito: Estrutura de repetiÃ§Ã£o para verificar se todas as letras foram adivinhadas.
        if "_" not in palavra_atual:
            print(f" VITÃ“RIA! A palavra era: {palavra_secreta} ")
            return # Encerra a funÃ§Ã£o

        # 4. Entrada do UsuÃ¡rio
        tentativa = input("Chute uma letra: ").strip().upper()

        # ValidaÃ§Ã£o de entrada
        if len(tentativa) != 1 or not tentativa.isalpha():
            print(" Por favor, chute apenas uma letra!\n")
            continue

        # 5. Processamento da Tentativa
        # Conceito: Estrutura Condicional aninhada para verificar o estado da letra.
        if tentativa in letras_certas or tentativa in letras_erradas:
            print(f"VocÃª jÃ¡ tentou a letra '{tentativa}'. Tente outra.\n")
        elif tentativa in palavra_secreta:
            print(f" Boa! A letra '{tentativa}' estÃ¡ na palavra.")
            letras_certas.append(tentativa)
        else:
            print(f" A letra '{tentativa}' nÃ£o estÃ¡ na palavra. O Fantasma avanÃ§a!")
            letras_erradas.append(tentativa)
            erros += 1

        print("-" * 30 + "\n")

    # 6. Derrota
    exibir_forca(erros)
    print(f" FIM DE JOGO! O Fantasma te pegou!")

    print(f"A palavra era: {palavra_secreta}")
if __name__ == "__main__":
    jogar_forca()